\ifgerman{\chapter{Vorgeschlagene Methoden}}{\chapter{Proposed Methods}}
\label{methods}
As described in the previous section, current performance estimation methods can be roughly categorized into two sections. One group uses information present for the current state of a classifier, e.g. the cross-validation methods. The second, much smaller group takes a look at the performance development over time, up to the current iteration. This encompasses the fitting of function models expected to be of similar shape to the learning curve using already present performance estimates to extrapolate them to future iterations. Typical methods for the estimation of the already witnessed iterations include holdout testing and k-fold cross-validation \cite{FigueroaEtal2012}.

The methods proposed in this work focus on combining both groups in an attempt to use as much information as possible to increase the prediction quality; .632 bootstrapping and the likes focus on the set of available instances, ignoring the process that led to this state. In turn, curve fitting currently makes use of either subpar techniques to obtain the accuracies for each iteration or uses holdout samples which can be costly or not available at all.

To serve as an illustration of the thought process leading to the following techniques, we assume, without loss of generality, a dataset $D = {(\vec{x_i}, y_i)}$ with two class labels $y_i \in {0, 1}$ and $|D| = n$. From this set an active learner selects $k \leq n$ instances which serve as the training set $X_T$ of a classifier $c: \vec{x} \mapsto y$. We would like to know the prediction accuracy of $c$ for the set $D$.

\section{Performance estimation on training sub-sets}
The simplest way to obtain performances estimates for the process of instance selection would be to use \textit{leave-x-out(LXO) cross-validation}, with $x \in \{1,...,k-1\}$. This way, we obtain $k \choose x$ subsets of size $x$ from the original training set as well as corresponding test sets of size $k-x$, which enable the performance estimation. Both low computational cost for the individual estimates as well as unbiasedness \cite{RodriguezEtAl2013} are advantages of using \textit{LXO}. While the computational effort for each subset is low, the total amount of possible subsets is $2^k - 2$, resulting in exponential complexity if used natively. Thus, some kind of sampling to reduce the complexity seems desirable.

Another option with regard to the estimation is \textit{bootstrapping}. It offers a little more variety, for different types \textit{na\"{i}ve}, \textit{leave-one-out} and \textit{.632} come to mind. This comes at a price, however; additional computational effort for the creation and testing of the bootstrap samples is necessary. Also, it isn't trivial how to create and handle the subsets. One could proceed similar to its cross-validation counterpart, sampling from the training set without replacement and using that subset as base for the bootstrap. This has two obvious downsides: for one, we are unable to obtain performance estimates for set sizes of one (except for na\"{i}ve bootstrap, which doesn't require that test instances are not within the bootstrap sample). Also, the instances not selected for the subset could be used as (additional) test sets, as they are with cross-validation. However, the influence this would have on the .632 family is unclear; although theoretically additional test instances should not influence ???????????????

However, multiple options remain regarding the usage of the individual estimates. Originally, leave-one-out cross-validation uses the arithmetic mean to obtain the final value. In our case, the estimates for each iteration could be averaged, resulting in $k-1$ data points. Another possibility would be to simply pick one estimate for each iteration fitting a curve for them. As this drastically reduces the amount of estimations used, it would be wise to 

To be able to use the training process in the estimation, we make the assumption that the active learner works iteratively, regardless if it actually does. In each iteration, one instance is added to the training set $\tilde{X}_T$, starting at size zero and stopping at size $k-1$. The order of the instance selection does not have to match that of $X_T$; this allows for the simulation of not one, but $k!$ selection processes, as it corresponds to an urn model, sampling instances without replacement.

\textit{Leave-one-out cross validation} is one of the more popular, and at the same time most basic, techniques for performance estimation. Its main advantages are relatively low computational effort and implementation complexity. Additionally, \textit{LOO} for $n$ training instances produces an unbiased estimate for a classifier trained with $n-1$ instances \cite{RodriguezEtAl2013}. 

\todots